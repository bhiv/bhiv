structs:
<task>: Fqn, Glue, Options

verbes: $()

.goto            // $1 as path, $2 as closure

.format          // $1 as a glue
/** To execute a function */
.then(<identifier>, <glue>)        => PostCall(This)

/** To transform a value */
.apply(<path>, <identifier>)       => This

/** To execute multiple tasks in parallel */
.Race(<glue>)                      => Race(This)
.  At(<path>)                      => Waterfall(This)
.end()                             => This

/** To iterate over each element */
/*    { key, value, flow } ->  value */
.Map(<path>, <options>)            => Waterfall(This)
.end()                             => This

/** To iterate over a list in order to pass a accumulator from a function to the next */
/*    { key, value, flow, accu } -> accu */
.Fold(<path>, <options>)           => Waterfall(This)
.end()                             => This

/** To filter a collection */
/*    { key, value, flow } -> Boolean:keep */
.Filter(<glue>, <options>)
.end()

/** To filter a collection */
/*    { key, value, flow } -> Boolean:keep */
.Detect(<glue>, <options>)
.end()

.Memoize         // $1 as duration (ms) or key => data, $2 as glue for key
.  end

.Match           // test $1 
.  when          // $1 is a pattern, then execute <task>
.  otherwise     // execute <task>
.  end

.shunt           // if $1 == true then go out, with $2 glue

.trap            // if $1 == true then catch error and execute <task>
.  end

.Unless          // if $1 == false then execute <task> before continue
.  end

.Until           // execute block with { flow, times } until $1 test return true
.  end

.end             // terminate waterfall (if root return ast)

----------------------------------------------------------------------------------

[a, b, c]                           // list of parallel tasks
{ a, b, c }                         // map of parallel tasks
function (d, c) {}                  // asynchronous function
function (d) {}                     // synchronous function
'$:[...]'                           // query string syntax (jmespath or custom one)
{ $: [A, B, C] }                    // waterfall - $()
{ $: 'F.Q.N:method' }               // then
{ $: { type: 'race', threads } }    // race
{ $: { type: 'map', iterator } }    // map
{ $: { type: 'fold', iterator } }   // fold
{ $: { type: 'filter', iterator } } // filter
{ $: { type: 'detect', iterator } } // detect




