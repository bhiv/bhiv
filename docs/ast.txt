/** To change the current working node */
.relocate(<location>)              => Self

/** To transform the flow */
.format(<glue>)                    => Self

/** To execute a function */
.then(<identifier>, <glue>)        => Merger(Self)
> .merge()                         => Parent
> .wrap(<glue>)                    => Parent
> .put(<path>)                     => Parent
> .replace(<path>)                 => Parent

/** To transform a value */
.apply(<path>, <identifier>)       => Self

/** To execute a serie of tasks */
.Waterfall()                       => Waterfall(Self)
.  end()                           => Parent

/** To execute multiple tasks in parallel */
/*    { flow, value } -> value */
.Race(<glue>)                      => Race(Self)
.  At(<path>)                      => RaceBranch(Self)
.  end()                           => Parent

/** To branch worflow */
.Match(<glue>)                     => Match(Self)
.  When(<test>)                    => MatchCase(Self)
.  Otherwise()                     => Waterfall(Self)
.  end()                           => Parent

/** To execute a sub workflow only if condition do not satisfy */
.Unless(<test>)                    => Waterfall(Self)
.  end()                           => Parent

/** To make an execution loop */
/*    { flow, times } -> flow */
.Until(<test>[, <delay>])          => Waterfall(Self)
.  end()                           => Self

/** To iterate over each element */
/*    { key, value, flow } ->  value */
.Map(<path>[, <options>])          => Waterfall(Self)
.  end()                           => Self

/** To iterate over a list in order to pass a accumulator from a function to the next */
/*    { key, value, flow, accu } -> accu */
.Fold(<path>[, <options>])         => Waterfall(Self)
.  end()                           => Self

/** To filter a collection */
/*    { key, value, flow } -> Boolean:keep */
.Filter(<glue>[, <options>])       => Waterfall(Self)
.  end()                           => Self

/** To find the first item which respond positively */
/*    { key, value, flow } -> value */
.Detect(<glue>[, <options>])       => Waterfall(Self)
.  end()                           => Self

/** To memoize a success execution result for a limited duration */
.memoize(<duration>[, <key>])      => Waterfall(Self)

/** To return a value if specific condition */
.shunt(<test>[, <glue>])           => Waterfall(Self)

/** To catch an error if pattern match */
.trap()                            => Waterfall(Self)

----------------------------------------------------------------------------------

[a, b, c]                           // list of parallel tasks
{ a, b, c }                         // map of parallel tasks
function (d, c) {}                  // asynchronous function
function (d) {}                     // synchronous function
'$:[...]'                           // query string syntax (jmespath or custom one)
{ $: [A, B, C] }                    // waterfall - $()
{ $: 'F.Q.N:method' }               // then
{ $: { type: 'race', threads } }    // race
{ $: { type: 'map', iterator } }    // map
{ $: { type: 'fold', iterator } }   // fold
{ $: { type: 'filter', iterator } } // filter
{ $: { type: 'detect', iterator } } // detect




