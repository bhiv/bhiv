/** To change the current working node
 */
.relocate(<location>) => Self

/** To transform the flow
 */
.as(<glue>) => Self

/** To execute a function
 */
.then(<identifier>[, <glue>]) => Merger Self

/** To transform a value
 */
.apply(<path>, <identifier>) => Self

/** To execute a serie of tasks
 */
.Waterfall() => Waterfall Self
.  end()     => Parent

/** To execute multiple tasks in parallel
 *    @subflow: { flow, value } -> value
 *    @glue: to change the subflow
 *    @path: branch to set or replace, can not be defined twice
 */
.Race(<glue>)                      => Race Self
.  At(<path>)                      => RaceBranch Self
.  end()                           => Merger Parent

/** To make an execution loop
 *    @subflow: { flow, times } -> flow
 *    @test: (*)       => execute subwaterfall until @test return a truly value
 *    @delay: (number) => wait @delay before doing it again
 */
.Until(<test>[, <delay>])          => Waterfall Self
.  end()                           => Self

/** To iterate over each element
 *    @subflow: { key, value, flow } ->  value
 *    @source: (null | undefined | '.') => current flow
 *    @source: (string)                 => path to array (e.g. path.to.array)
 *    @source: (array)                  => it's source itself
 */
.Map([<source>]) => Waterfall Self
.  end()         => Merger Self

/** To iterate over a list in order to pass a accumulator from a function to the next */
 *    @subflow: { key, value, flow, accu } ->  value
 *    @accu: *
 *    @source: (null | undefined | '.') => current flow
 *    @source: (string)                 => path to array (e.g. path.to.array)
 *    @source: (array)                  => it's source itself
.Fold([<accu>[, <source>]]) => Waterfall Self
.  end()                    => Merger Self

/** To iterate over each element
 *    @subflow: { key, value, flow } ->  value
 *    @source: (null | undefined | '.') => current flow
 *    @source: (string)                 => path to array (e.g. path.to.array)
 *    @source: (array)                  => it's source itself
 */
.Reduce([<source>]) => Waterfall Self
.  end()            => Merger Self

/** To filter a collection */
 *    @subflow: { key, value, flow } -> Boolean:keep
 *    @source: (null | undefined | '.') => current flow
 *    @source: (string)                 => path to array (e.g. path.to.array)
 *    @source: (array)                  => it's source itself
 */
.Filter([<source>]) => Waterfall Self
.  end()            => Merger Self

/** To find the first item which respond positively
 *    @subflow: { key, value, flow } -> value
 *    @source: (null | undefined | '.') => current flow
 *    @source: (string)                 => path to array (e.g. path.to.array)
 *    @source: (array)                  => it's source itself
 */
.Detect([<source>]) => Waterfall Self
.  end()            => Merger Self

/** To branch workflow
 *    @view: (string | Object)                => a query to extract from flow a subset of data
 *    @test: (string | Function | RegExp)     => 
 *    @value: (null | bool | number | string) => 
 *    @type: (string)
 */
.Match([<view>])           => Match Self
.  When(<test>)            => MatchCase Waterfall Self
.  WhenEqual(<value>)      => MatchCase Waterfall Self
.  WhenType(<type>[, ...]) => MatchCase Waterfall Self
.  Otherwise()             => Waterfall Self
.  end()                   => Merger Parent

/** To execute a sub workflow only if condition do not satisfy
 *    @test: * => execute subwaterfall unless @test return a truly value
 */
.Unless(<test>)                    => Waterfall Self
.  end()                           => Parent

/** To memoize a success execution result for a limited duration */
.memoize(<duration>[, <key>])      => Waterfall Self

/** To return a value if specific condition */
.shunt(<test>[, <glue>])           => Waterfall Self

/** To catch an error if pattern match */
.trap()                            => Waterfall Self

--------------------------------------------

/** To merge result with flow
 */
.merge(<path>) => Parent

/** To merge in specific way the reesult and flow
 *    @subflow: { payload, result } -> flow
 */
.wrap(<glue>)                    => Parent

/** To replace
 */
.replace(<path>)                 => Parent


----------------------------------------------------------------------------------

[a, b, c]                           // list of parallel tasks
{ a, b, c }                         // map of parallel tasks
function (d, c) {}                  // asynchronous function
function (d) {}                     // synchronous function
'$:[...]'                           // query string syntax (jmespath or custom one)
{ $: [A, B, C] }                    // waterfall - $()
{ $: 'F.Q.N:method' }               // then
{ $: { type: 'race', threads } }    // race
{ $: { type: 'map', iterator } }    // map
{ $: { type: 'fold', iterator } }   // fold
{ $: { type: 'filter', iterator } } // filter
{ $: { type: 'detect', iterator } } // detect




